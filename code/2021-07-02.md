



# [Find K Closest Elements](https://leetcode.com/explore/featured/card/july-leetcoding-challenge-2021/608/week-1-july-1st-july-7th/3800/)




#### 题意：
> Given a  **sorted**  integer array  `arr`, two integers  `k`  and  `x`, return the  `k`  closest integers to  `x`  in the array. The result should also be sorted in ascending order. <br/>
>An integer  `a`  is closer to  `x`  than an integer  `b`  if: <br/>
>-   `|a - x| < |b - x|`, or
>-   `|a - x| == |b - x|`  and  `a < b`





### 思路：
**方法1** ： 用一个**List<int[]>** ，每个element存两个数，第一个数是 **A[i] - x**, 第二个数是 x。然后我们直接sort 这个list 就可以。先按绝对差排序，如果一样，按原来的A[i] 排序   O(nlogn）<br/><br/><br/>

**方法2** : 先用二分法找出第一个 >= x 的数字，然后在这个位置上做双指针的移动。
O(klogk)





### :bulb:代码 C++ 方法2：
```c++
class Solution {
public:
    vector<int> findClosestElements(vector<int>& A, int k, int x) {
        vector<int> res;
        int l = 0, r = A.size()-1;
        int i = -1, j = -1;
        while(l <= r){
            int mid = l + (r - l)/2;
            if(A[mid] >= x){
                j = mid;
                r = mid - 1;
            }
            else{
                l = mid + 1;
            }
        } //O(log n) binarySearch find the position of the first number >= x
        
        
        if(j == -1){// no element >=x
            for(int x = A.size() - 1; x >= 0 && res.size() < k; x--){
                res.push_back(A[x]);
            }
        }
        else{//use two pointer
            i = j - 1;
            while(res.size() < k && i >=0 && j < A.size()){
                if(abs(A[i] - x) <= abs(A[j] - x)){
                    res.push_back(A[i--]);
                }    
                else{
                    res.push_back(A[j++]);
                }
            }
            
            while(res.size() < k && i >= 0){
                res.push_back(A[i--]);
            }
            
            while(res.size() < k && j < A.size()){
                res.push_back(A[j++]);
            }
            
        }
        sort(res.begin(),res.end());
        return res;
    }
};  

//O(k log k) 
```

### :bulb:代码 Java 方法1：
```java
class Solution {
    public List<Integer> findClosestElements(int[] A, int k, int x) {
        List<int[]> list = new ArrayList<>();
        for(int i = 0; i < A.length; i++){
            list.add(new int[]{Math.abs(A[i] - x), A[i]});
        }
        
        Collections.sort(list, (a,b) ->{
            if(a[0] == b[0]){
                return a[1] - b[1];
            }
            return a[0] - b[0];
        });
        
        List<Integer> res = new ArrayList<>();
        for(int i = 0; i < k; i++){
            res.add(list.get(i)[1]);
        }
        
        Collections.sort(res);
        
        return res;
    }
}
//O(nlogn + klogk) == O(nlogn)
```

### :bulb:代码 Go：
```
func findClosestElements(A []int, k int, x int) []int {
    B := make([][]int,len(A))
    res := make([]int,0)
    for i := 0; i < len(B); i++{
        B[i] = make([]int,2)
        B[i][0] = int(math.Abs(float64(A[i] - x)))
        B[i][1] = A[i]
    }
    
    sort.Slice(B[:], func(i, j int) bool {
        for x := range B[i] {
            if B[i][x] == B[j][x] {
                continue
            }
            return B[i][x] < B[j][x]
        }
        return false
    })
    
    for i := 0; i < k; i++{
        res = append(res, B[i][1])
    }
    
    sort.Ints(res)
    return res   
}
```

#### 空间复杂度和时间复杂度：
  - 时间复杂度：根据方法不一样
  - 空间复杂度：
<br/><br/>







